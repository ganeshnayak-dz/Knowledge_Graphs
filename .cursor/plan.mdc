---
alwaysApply: true
---

# Knowledge Graph — Learning & Development Plan

**Purpose:** Build graph and Cypher skills, then add NL→Cypher (Groq), then hybrid graph+vector. No shortcuts — proper engineering, interview-worthy.

**Dataset:** Custom movie dataset (`movie.csv`) — movie metadata with movie_id, movie_name, year, overview, director, genre (comma-separated), cast (comma-separated).  
*No user ratings; graph is movie–genre–person (directors/actors).*

---

## Phase 1 — No LLM (Pure Graph Foundation) ✅ Implemented

**Goal:** Understand graph modeling, learn Cypher, think in relationships, build something interview-worthy.

**Phase 1 implementation:** Python ingest pipeline; Neo4j; movie dataset with Movie, Genre, Person (directors/actors).

### Step 0 — Setup Environment

- [x] **Install Neo4j** (Desktop or Docker)
- [x] **Python env:** `phase1/requirements.txt` (neo4j, pandas, pydantic, pydantic-settings)
- [x] **Config:** `.env` with `NEO4J_URI`, `NEO4J_USER`, `NEO4J_PASSWORD`, `NEO4J_DB` (see `.example.env`)
- [ ] Open Neo4j Browser: `http://localhost:7474`

### Step 1 — Dataset

- [x] **Used:** Custom movie dataset — `phase1/data/movie.csv`
- **Columns:** `movie_id`, `movie_name`, `year`, `overview`, `director`, `genre` (comma-separated), `cast` (comma-separated)

### Step 2 — Graph Schema (as implemented)

**Nodes:** `Movie` (movie_id, name, year, overview), `Genre` (name), `Person` (name — used for directors and actors)  
**Relationships:** `Movie -[:HAS_GENRE]-> Genre`, `Person -[:DIRECTED]-> Movie`, `Person -[:ACTED_IN]-> Movie`

*Graph schema = meaning (entities + relationships), not columns/tables.*

### Step 3 — Code Structure

- [x] **core/config.py** — Settings from `.env` (Neo4j URI, user, password, db)
- [x] **db/connection.py** — `Neo4jConnection` (execute Cypher with params)
- [x] **models/movie.py** — `MovieModel` (Pydantic) for validation (movie_id, movie_name, year, overview, director, genre[], cast[])
- [x] **graph/schema.py** — Cypher: constraints, CREATE_MOVIE, CREATE_GENRE_REL, CREATE_DIRECTOR_REL, CREATE_ACTOR_REL
- [x] **ingest/load_data.py** — Read CSV, validate rows, create constraints, then for each row: create Movie, HAS_GENRE, DIRECTED, ACTED_IN
- [x] **main.py** — Entry: `ingest_movies(path_to_movie.csv)`

### Step 4 — Run Ingest

- [ ] From `phase1/code`: set `.env`, then run:  
  `python main.py` (uses `phase1/data/movie.csv` by default in main)
- [ ] Verify: In Neo4j Browser — `MATCH (n) RETURN labels(n), count(n);` and `MATCH ()-[r]->() RETURN type(r), count(r);`

### Step 5 — Constraints (in code)

- [x] **Implemented in schema.py:**  
  `Movie.movie_id` UNIQUE, `Person.name` UNIQUE, `Genre.name` UNIQUE  
  (Created at start of ingest.)

### Step 6 — Explore & Write Cypher Queries

- [ ] Count nodes: `MATCH (n) RETURN labels(n), count(n);`
- [ ] Count relationships: `MATCH ()-[r]->() RETURN type(r), count(r);`
- [ ] **Example queries (movie-metadata graph):**
  - Movies by genre: `MATCH (m:Movie)-[:HAS_GENRE]->(g:Genre {name: "Drama"}) RETURN m.name;`
  - Movies by director: `MATCH (p:Person)-[:DIRECTED]->(m:Movie) WHERE p.name = $name RETURN m.name;`
  - Co-actors: `MATCH (a:Person)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(b:Person) WHERE a.name = $name AND a <> b RETURN b.name, count(m) ORDER BY count(m) DESC;`
- [ ] **Target:** 10–15 Cypher queries (traversal, filters, aggregates)

### Phase 1 Deliverables

- [x] Neo4j + Python ingest pipeline; movie data loaded from `movie.csv`
- [x] Schema: Movie, Genre, Person + HAS_GENRE, DIRECTED, ACTED_IN
- [x] Constraints: Movie.movie_id, Person.name, Genre.name
- [ ] 10–15 Cypher queries (by genre, director, cast, co-actors, etc.)
- [ ] README: setup (.env, run main.py), schema, example queries

### Phase 1 — DO NOT

- No Groq / no LLM
- No PDFs, no vector DB
- First master Cypher on this schema

### Suggested Timeline (Phase 1)

- **Day 1:** Setup + dataset + ingest code (Steps 0–4)
- **Day 2:** Explore graph + write 10–15 Cypher queries (Step 6)
- **Day 3:** Clean-up, README (Step 6 + docs)

---

## Phase 2 — Add Groq (NL → Cypher)

**Goal:** Natural language → Cypher; validate generated queries.

- [ ] Integrate Groq (or chosen LLM) to translate user questions to Cypher
- [ ] Validate/sanitize generated Cypher before execution
- [ ] Expose a simple interface (CLI or minimal API) for “ask in English, run on graph”

*Start only after Phase 1 is solid (10–15 queries written by hand).*

---

## Phase 3 — Advanced (Hybrid Graph + Vector)

**Goal:** Combine graph with vector search; PDF ingestion.

- [ ] Add vector store (e.g. for document chunks)
- [ ] PDF ingestion pipeline
- [ ] Hybrid: graph traversal + vector similarity where appropriate

*Start only after Phase 2 NL→Cypher is working.*

---

## Success Criteria (Phase 1)

By end of Phase 1 you should be able to:

- Model entities and relationships in graph terms (Movie, Genre, Person; HAS_GENRE, DIRECTED, ACTED_IN)
- Run the Python ingest pipeline and load movie data into Neo4j
- Traverse the graph (single and multi-hop: e.g. movies by genre, by director, co-actors)
- Aggregate over paths (count, top directors, etc.)
- Explain how graph thinking differs from SQL
- Confidently write 10–15 Cypher queries on the movie graph

Then proceed to Phase 2 (NL → Cypher with Groq).
